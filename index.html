<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leaflet TimeDimension Demo</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.5.1/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.control.min.css" />
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        #map {
            height: 100%;
            width: 100%;
        }
        .export-import-tooltip {
            background-color: rgba(255, 255, 128, .5);
        }
        .custom-tooltip1 .tooltip-box {
            display: inline-block;
            color: blue;
            white-space: nowrap; /* Текст не переноситься на новий рядок */
            background: rgba(255, 255, 255, 1); /* Прозорий білий фон */
             /*border: 1px solid black; Чорна рамка */
            border-radius: 5px; /* Заокруглені кути */
            padding: 0px 2px; /* Відступи всередині боксу */
            text-align: center; /* Центруємо текст */
            font-size: 14px; /* Розмір шрифту */
            font-weight: bold; /* Жирний текст */
            box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2); /* Легка тінь */
            transform: translate(-50%, -10%);/* Розташування під маркером */
        }
        .imp-exp-block {
            display: flex;
            align-items: center;
            align-content: center;
            flex-direction: column;
            background-color: white;
            margin-top: 30%;
        }
        .donations-box {
            position: absolute;
            z-index: 9999; 
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: 	rgb(235, 224, 224, 0.5);
            width: 100%;
        } 
        .donations-block{
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Comic Sans MS, Comic Sans, cursive;
            padding-left: 2%;
            padding-right: 2%;
            width: 50%;
            height: 100%;
            max-height: 100%;
            background-color: rgba(140, 140, 140, 0.7);
            text-align: center;
            -webkit-box-shadow: 0px 0px 13px 5px rgba(0,0,0,0.75);
            -moz-box-shadow: 0px 0px 13px 5px rgba(0,0,0,0.75);
            box-shadow: 0px 0px 13px 5px rgba(0,0,0,0.75);
        }
        .donation-text{
            font-size: calc(0.8vw + 1vh);
            margin-top: 2%;
            
        }
        .donations-buttons{
            margin-top: 7%;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: space-around;
            width: 100%;
            
        }
        .donations-buttons button {
            background-color: grey;
            border: 1px solid black;
            border-radius: 2%;
            padding: 1%;
            text-align: center;
            width: 40%;
            font-size: calc(0.8vw + 1vh);

            font-family: Comic Sans MS, Comic Sans, cursive;
            -webkit-box-shadow: 0px 0px 13px -2px rgba(0,0,0,0.75);
            -moz-box-shadow: 0px 0px 13px -2px rgba(0,0,0,0.75);
            box-shadow: 0px 0px 13px -2px rgba(0,0,0,0.75);
        }
        .donations-buttons button:hover{
            transform: scale(1.1, 1.1);
            cursor: pointer;
        }

        .display-none {
            display: none;
        }

        .leaflet-legend {
            background: white;
            padding: 10px;
            margin: 10px;
            border: 2px solid black;
            display: flex;
            flex-direction: column;
            align-content: center;
        }
        .leaflet-legend div{
            display: flex;
            flex-direction: row;
            margin: 8px;
        }

        .leaflet-legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            
            opacity: 0.7;
        }

        .leaflet-legend .green {
            background: green;
        }

        .leaflet-legend .purple {
            background: #8700b0;
        }

        .leaflet-legend .red {
            background: red;
        }



        .leaflet-legend .black {
            background: black;
            border-radius: 50%;
            border: 2px solid yellow;
        }

        .leaflet-legend .blue {
            background: #00d0ff;
            border-radius: 50%;
            border: 2px solid black;
        }



        
    </style>    
</head>
<body>
    <div class="donations-box" id="donation">
        <div class="donations-block">
            <div>
                <div style="font-size: calc(2.5vw + 1vh); font-weight: bold; margin-top: 20%;">Вітаємо на PPM!</div>
                <div style="font-size: calc(1vw + 1vh); font-weight: bold;margin-top: 10px;">POLAND POWER MAP</div>
            </div>
            <div style="margin-top: 7%;">
                <div class="donation-text">Проєкт перебуває на активній стадії розробки та продовжує розвиватися щодня!</div>
                <div class="donation-text">Однак, на жаль, наші можливості обмежені програмістом на пів ставки та серверним забезпеченням GitHub.</div>
                <div class="donation-text">Задля покращення та прискорення роботи команда збирає пожертви на ArcGIS — провідну платформу для роботи з географічними інформаційними системами.</div>
                <div class="donation-text">Середовище надасть можливість ефективно створювати об'ємні інформаційні карти, візуалізувати та аналізувати дані у зручних інтерактивних додатках.</div>
                <div class="donation-text">Дякуємо за вашу підтримку та за те, що обираєте саме нас!</div> 
            </div>
            <div class="donations-buttons">
                <button style="background-color: #9eb89a;">Зробити пожертву &#x2764;</button>
                <button onclick="clossebut()" style="background-color: #a68389;">Безсердечно відмовити</button>
            </div>
        </div>   
    
    </div>
    <div id="map"></div>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.5.1/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/iso8601-js-period@0.2.1/iso8601.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.1/dist/leaflet.timedimension.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://unpkg.com/esri-leaflet/dist/esri-leaflet.js"></script>
   
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

    <!-- JavaScript для MarkerCluster -->
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <script>

        function clossebut(){
            const dispNone = document.getElementById("donation")
            dispNone.classList.add("display-none");
        }

        // URLs для GeoJSON файлів
        var exportImportUrl = 'https://storage.googleapis.com/yazadovbavsia/export_import_data.geojson';
        var powerPlantsUrl = 'https://storage.googleapis.com/yazadovbavsia/elektrownie.geojson';
        var dayscount = 7
        // Створення карти
        var map = L.map('map', {
            zoom: 7,
            center: [52.196893, 18.626428],
            timeDimension: true,
            timeDimensionOptions: {
                period: 'PT1H' // Крок у 1 годину
            },
            timeDimensionControl: true,
            timeDimensionControlOptions: {
                autoPlay: false,
                timeZones: ["gb"],
                timeFormat: 'YYYY-MM-DD HH:mm:ss',
                timeSliderDragUpdate: true,
                playerOptions: {
                    transitionTime: 1500,
                     // Починати спочатку після завершення
                    direction: -1, // Обрізання: зворотній напрямок
                },
              
    },
        });

        var legend = L.control({ position: 'bottomright' });

        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'leaflet-legend');
            div.innerHTML = 
                            '<div><i class="green"></i> 220kV Лінії</div>' +
                            '<div><i class="purple"></i> 400kV Лінії</div>' +
                            '<div><i class="red"></i> 110kV Лінії</div>' +
                            '<div><i class="blue"></i> PSE підстанції</div>' +
                            '<div><i class="black"></i> Проекти GPZ</div>';
            return div;
        };

        legend.addTo(map)
        
        // Додавання плиток карти (OpenStreetMap)
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png').addTo(map);

        var tooltipMarkers = [];
        // Функція для завантаження та створення шару для експорту/імпорту
        function loadExportImportLayer() {
            var tooltipMarkers = [];
            var countryCoordinates = {
                Litwa: [23.821156, 54.618995],
                Czechy: [15.867570, 50.059313],
                Niemcy: [13.340339, 52.518312],
                Szwecja: [16.856339, 55.262268],
                Ukraina: [25.085099, 50.347622],
                Słowacja: [20.240128, 49.076085],
            };

            const geoJsonData = {
                type: "FeatureCollection",
                features: []
            };

            const today = new Date();
            const promises = [];

            for (let i = 0; i < dayscount; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() - i);
                const dateString = date.toISOString().split('T')[0];
                const apiUrl = `https://api.raporty.pse.pl/api/przeplywy-mocy-export?` + 
                    `$select=Doba%20handlowa,OREB,Czechy%20Eksport%20%5BMW%5D,Czechy%20Import%20%5BMW%5D,` + 
                    `S%C5%82owacja%20Eksport%20%5BMW%5D,S%C5%82owacja%20Import%20%5BMW%5D,` + 
                    `Niemcy%20Eksport%20%5BMW%5D,Niemcy%20Import%20%5BMW%5D,` + 
                    `Szwecja%20Eksport%20%5BMW%5D,Szwecja%20Import%20%5BMW%5D,` + 
                    `Ukraina%20Eksport%20%5BMW%5D,Ukraina%20Import%20%5BMW%5D,` + 
                    `Litwa%20Eksport%20%5BMW%5D,Litwa%20Import%20%5BMW%5D,Data%20publikacji&` + 
                    `$filter=business_date%20eq%20%27${dateString}%27`;

                promises.push(fetch(apiUrl).then((response) => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                }).then((data) => {
                    const entries = data.value;
                    entries.forEach((entry) => {
                        Object.keys(countryCoordinates).forEach((country) => {
                            const exportKey = `${country} Eksport [MW]`;
                            const importKey = `${country} Import [MW]`;

                            if (exportKey in entry && importKey in entry) {
                                const { hours, minutes } = getTimeFromOreb(entry.OREB);
                                const dobaHandlowa = new Date(entry["Doba handlowa"]);
                                const fullDateTime = new Date(
                                    dobaHandlowa.setHours(dobaHandlowa.getHours() + hours, minutes)
                                );

                                geoJsonData.features.push({
                                    type: "Feature",
                                    geometry: {
                                        type: "Point",
                                        coordinates: countryCoordinates[country]
                                    },
                                    properties: {
                                        country: country,
                                        export: entry[exportKey],
                                        import: entry[importKey],
                                        dateTime: fullDateTime.toISOString()
                                    }
                                });
                            }
                        });
                    });
                }).catch((error) => console.error('Error fetching data:', error)));
            }

            return Promise.all(promises).then(() => {
                geoJsonData.features.forEach(feature => {
                    if (feature.properties && feature.properties.dateTime) {
                        feature.properties.time = new Date(feature.properties.dateTime).toISOString();
                    }
                });

                const timestamps = geoJsonData.features.map(feature => new Date(feature.properties.dateTime));
                const minDate = new Date(Math.min(...timestamps));
                const maxDate = new Date(Math.max(...timestamps));

                map.timeDimension.options.timeInterval = `${minDate.toISOString()}/${maxDate.toISOString()}`;
                map.timeDimension.options.period = 'PT1H';

                const geoJsonLayer = L.geoJSON(geoJsonData, {
                    pointToLayer: function (feature, latlng) {
                        return L.circleMarker(latlng, {
                            radius: 3,
                            color: 'black',
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                    },
                    onEachFeature: function (feature, layer) {
                        var popupContent = `
                            <b>Країна:</b> ${feature.properties.country || 'Невідомо'}<br>
                            <b>Експорт (MW):</b> ${feature.properties.export}<br>
                            <b>Імпорт (MW):</b> ${feature.properties.import}<br>
                            <b>Час:</b> ${feature.properties.dateTime || 'Невідомо'}`;
                        layer.bindPopup(popupContent);
                    }
                });

                var timeDimensionLayer = L.timeDimension.layer.geoJson(geoJsonLayer, {
                    updateTimeDimension: true,
                    addLastPoint: true,
                    duration: 'PT1H'
                });

                map.timeDimension.on('timeload', function () {
                    tooltipMarkers.forEach(marker => map.removeLayer(marker));
                    tooltipMarkers = [];

                    geoJsonLayer.eachLayer(function (layer) {
                        var feature = layer.feature;
                        var currentTime = map.timeDimension.getCurrentTime();

                        if (feature.properties.time && new Date(feature.properties.time).getTime() === new Date(currentTime).getTime()) {
                            var Export = feature.properties.export;
                            var Import = feature.properties.import;
                            console.log(feature.properties);
                            var tooltip = L.divIcon({
                                className: 'custom-tooltip',
                                html: `
                                    <div class="imp-exp-block">
                                        <span style="font-size: 10px; text-align: center; color: Black; font-weight: bold;">
                                            ${feature.properties.country}
                                        </span>
                                        <span style="font-size: 15px; text-align: center; color: blue; font-weight: bold;">
                                            ${Math.round(Import)/1000} GW
                                        </span>
                                        <span style="font-size: 15px; text-align: center; color: red; font-weight: bold;">
                                            ${Math.round(Export)/1000} GW
                                        </span>
                                    </div>
                                `,
                                iconSize: [100, 50],
                            });

                            var tooltipMarker = L.marker(layer.getLatLng(), { icon: tooltip }).addTo(map);
                            tooltipMarkers.push(tooltipMarker);
                        }
                    });
                });

                return timeDimensionLayer;
            }).catch((error) => console.error('Error fetching data:', error));
        }
        
        

        // Функція для обробки OREB
        function getTimeFromOreb(oreb) {
            const [startTime] = oreb.split(' - ');
            const [hours, minutes] = startTime.split(':').map(Number);
            return { hours, minutes };
        }

        
        function loadPowerPlantsLayer() {
            const tooltipMarkers = [];
            const coordinates = {
                                "Bełchatów": [19.325833,51.2675],
                                "Kozienice": [21.464444, 51.665278,],
                                "Opole": [17.883889, 50.751389],
                                "Jaworzno 3": [19.206667, 50.208611],
                                "Połaniec": [21.333528, 50.435111],
                                "Rybnik": [18.526278, 50.133083],
                                "Turów": [14.912056, 50.94725],
                                "Dolna Odra": [14.463452, 53.20592],
                                "Pątnów 2": [18.236111, 52.301111],
                                "Łaziska 3": [18.846417, 50.132778],
                                "Łagisza": [19.1475, 50.349444],
                                "Ostrołęka B": [21.613056, 53.104167],
                                "Siersza": [19.4625, 50.206111],
                                "Skawina": [19.803889, 49.975889],
                                "EC Stalowa Wola": [22.075967, 50.550439]
                            };

            const geoJsonData = {
                type: "FeatureCollection",
                features: []
            };

            const today = new Date();
            const promises = [];

            for (let i = 0; i < dayscount; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() - i);
                const dateString = moment(date).format('YYYY-MM-DD');
                const urlE = `https://api.raporty.pse.pl/api/gen-jw-export?$select=Doba%20handlowa,OREB,Elektrownia,Kod%20JW,Tryb%20pracy,wartosc,Data%20publikacji&$orderby=udtczas_utc,%20%27Kod%20JW%27&$first=15000&$filter=business_date%20eq%20%27${dateString}%27`;

                promises.push(fetch(urlE).then((response) => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                }).then((responseData) => {
                    const data = responseData.value;

                    const filteredData = data.filter(item => item.wartosc !== null);
                    filteredData.forEach(item => {
                        item["Data publikacji"] = moment(item["Data publikacji"]).toDate();
                    });

                    const groupedData = {};
                    filteredData.forEach(item => {
                        const key = `${item.OREB}-${item.Elektrownia}`;
                        if (!groupedData[key]) {
                            groupedData[key] = { ...item, wartosc: 0 };
                        }
                        groupedData[key].wartosc += item.wartosc;
                    });

                    function getTimeFromOREB(oreb) {
                        const [startTime] = oreb.split(' - ');
                        const [startHour, startMinute] = startTime.split(':').map(Number);
                        return { hours: startHour, minutes: startMinute };
                    }

                    const updatedGroupedData = Object.values(groupedData).map(item => {
                        const orebTime = getTimeFromOREB(item.OREB);
                        item["OREB_time"] = orebTime;
                        item["timestamp"] = moment(item["Doba handlowa"]).add(orebTime.hours, 'hours').add(orebTime.minutes, 'minutes');
                        return item;
                    });

                    updatedGroupedData.forEach(item => {
                        item.coordinates = coordinates[item.Elektrownia] || null;
                    });

                    const finalData = updatedGroupedData.filter(item => item.coordinates);
                    finalData.forEach(item => {
                        item["Doba handlowa"] = moment(item["Doba handlowa"]).format('YYYY-MM-DD HH:mm:ss');
                        item["Data publikacji"] = moment(item["Data publikacji"]).format('YYYY-MM-DD HH:mm:ss');
                        item["timestamp"] = moment(item["timestamp"]).format('YYYY-MM-DD HH:mm:ss');
                    });

                    geoJsonData.features.push(...finalData.map(item => ({
                        type: "Feature",
                        geometry: {
                            type: "Point",
                            coordinates: item.coordinates
                        },
                        properties: {
                            "OREB": item.OREB,
                            "Elektrownia": item.Elektrownia,
                            "Kod JW": item["Kod JW"],
                            "Tryb pracy": item["Tryb pracy"],
                            "wartosc": item.wartosc,
                            "Doba handlowa": item["Doba handlowa"],
                            "Data publikacji": item["Data publikacji"],
                            "timestamp": item["timestamp"]
                        }
                    })));

                }).catch((error) => console.error('Error fetching data:', error)));
            }

            return Promise.all(promises).then(() => {
                geoJsonData.features.forEach(feature => {
                    if (feature.properties && feature.properties.timestamp) {
                        const timestamp = feature.properties.timestamp.replace(' ', 'T') + 'Z';
                        feature.properties.time = new Date(timestamp).toISOString();
                    }
                });

                const geoJsonLayer = L.geoJSON(geoJsonData, {
                    pointToLayer: function (feature, latlng) {
                        const wartosc = feature.properties.wartosc || 0;
                        var size = Math.sqrt(wartosc) * 2;
                        return L.marker(latlng, {
                            icon: L.divIcon({
                                className: 'custom-marker',
                                html: `<div style="
                                    width: ${size / 2}px;
                                    height: ${size / 2}px;
                                    background-color: #910101;
                                    opacity: 0.5;
                                    border: 1px solid black;
                                    transform: translate(-40%, -40%);
                                "></div>`
                            })
                        });
                    },
                    onEachFeature: function (feature, layer) {
                        const wartosc = feature.properties.wartosc || 0;
                        const popupContent = `
                            <b>Електростанція:</b> ${feature.properties.Elektrownia || 'Невідомо'}<br>
                            <b>Потужність (MW):</b> ${Math.round(wartosc)}<br>
                            <b>Час:</b> ${feature.properties.timestamp || 'Невідомо'}`;
                        layer.bindPopup(popupContent);
                    }
                });

                const timeDimensionLayer = L.timeDimension.layer.geoJson(geoJsonLayer, {
                    updateTimeDimension: true,
                    addLastPoint: true,
                    duration: 'PT1H'
                });

                map.timeDimension.on('timeload', function () {
                    tooltipMarkers.forEach(marker => map.removeLayer(marker));
                    tooltipMarkers.length = 0;
                    
                    geoJsonLayer.eachLayer(function (layer) {
                        const feature = layer.feature;
                        const currentTime = map.timeDimension.getCurrentTime();
                        
                        if (feature.properties.time && new Date(feature.properties.time).getTime() === new Date(currentTime).getTime()) {
                            var wartosc = feature.properties.wartosc || 0;
                            var tiptop = feature.properties.Elektrownia
                            wartosc = wartosc / 1000;
                            var size = Math.sqrt(wartosc) * 2;
                            var tooltip;
                            if (tiptop == "Łagisza"){
                                tooltip = L.divIcon({
                                    className: 'custom-tooltip1',
                                    html: `<div class="tooltip-box">${wartosc.toFixed(2)}</div>`,
                                    iconSize: [size, size], // Дозволяємо автоматично підлаштовувати розмір
                                    iconAnchor: [size/0.1, size/0.03]
                                });
                            } else {
                                tooltip = L.divIcon({
                                    className: 'custom-tooltip1',
                                    html: `<div class="tooltip-box">${wartosc.toFixed(2)}</div>`,
                                    iconSize: [size, size], // Дозволяємо автоматично підлаштовувати розмір
                                    iconAnchor: [size/0.1, -size/0.1]
                                });
                            }
                            const textMarker = L.marker(layer.getLatLng(), { icon: tooltip }).addTo(map);
                            tooltipMarkers.push(textMarker);
                        }
                    });
                });

                return timeDimensionLayer;
            }).catch((error) => console.error('Error fetching data:', error));
        }

        Promise.all([loadExportImportLayer(),
         loadPowerPlantsLayer()
         ])
            .then((layers) => {
                layers.forEach(layer => layer.addTo(map));
                
            })
            .catch((error) => {
                console.error('Помилка завантаження шарів:', error);
            });
        
        // Завантаження всіх шарів
        var geojsonUrlLine = 'https://mark-000.github.io/pl-power-vis-map.github.io/power-lines-poland-all.geojson';
        var geojsonUrlGPZ = 'https://mark-000.github.io/pl-power-vis-map.github.io/pse-GPZ.geojson';
        var geojsonUrlProjekty = 'https://mark-000.github.io/pl-power-vis-map.github.io/pse-proekty-all-35r';
        var geojsonUrlRecons = 'https://mark-000.github.io/pl-power-vis-map.github.io/pse-recons-linii-all-shem.geojson'; // Новий шар
        var geojsonUrlJdr = 'https://mark-000.github.io/pl-power-vis-map.github.io/Polskie_Elektrownie_Jądrowe.geojson';
        var geojsonUrlBorder = 'https://mark-000.github.io/pl-power-vis-map.github.io/border-poland.geojson';
        
        var layer220, layer400, layer110, arcgisLayer, projektyLayer, reconsLayer, projektyJdr, borderLayer;


        var createLayer = (geojsonData, voltage) => {
            var filteredFeatures = geojsonData.features.filter(feature => 
                feature.properties.name && feature.properties.name.includes(voltage) || feature.properties.voltage && feature.properties.voltage.includes(voltage)
            );

            // Створення нового GeoJSON об'єкта
            var filteredGeojson = {
                type: "FeatureCollection",
                features: filteredFeatures
            };

            return L.geoJSON(filteredGeojson, {
                style: function(feature) {
                    return { color: voltage === "220" ? 'green' : voltage === "400" ? '#8700b0' : 'red', weight: 1,
                             weight: voltage === "220" ? 2 : voltage === "400" ? 2 : 1
                    };
                },
                onEachFeature: function(feature, layer) {
                    layer.bindPopup(`
                        <b>Name:</b> ${feature.properties.name || 'Unknown'}<br>
                        <b>circuits:</b> ${feature.properties.circuits || 'Unknown'}<br>
                        <b>cables:</b> ${feature.properties.cables || 'Unknown'}<br>
                        <b>Voltage:</b> ${feature.properties.voltage || 'Unknown'}
                    `);
                }
            });
        };

        // Створення шару з ArcGIS Feature Service
        arcgisLayer = L.esri.featureLayer({
            url: 'https://services1.arcgis.com/mQcAehnytds8jMvo/ArcGIS/rest/services/JPT__archiwum_państwowe/FeatureServer/0'
        }).setStyle({
            color: 'orange', // Можна змінити стиль
            weight: 2
        });
        console.log(arcgisLayer);
        fetch(geojsonUrlLine)
            .then(response => response.json())
            .then(geojsonData => {
                // Створення шарів для 220, 400, 110
                layer220 = createLayer(geojsonData, "220");
                layer400 = createLayer(geojsonData, "400");
                layer110 = createLayer(geojsonData, "110"); // Новий шар для 110 кВ

                fetch(geojsonUrlGPZ)
                    .then(response => response.json())
                    .then(gpzGeojsonData => {
                        gpzLayer = L.geoJSON(gpzGeojsonData, {
                            pointToLayer: function(feature, latlng) {
                                return L.circleMarker(latlng, {
                                    radius: 6, // Радіус точки
                                    fillColor: "#00d0ff", // Колір заповнення
                                    color: "black", // Колір обведення
                                    weight: 1, // Товщина обведення
                                    opacity: 1, // Прозорість обведення
                                    fillOpacity: 1 // Прозорість заповнення
                                });
                            },
                            onEachFeature: function(feature, layer) {
                                layer.bindPopup(`
                                    <b>Name:</b> ${feature.properties.name || 'Unknown'}<br>
                                    <b>voltage:</b> ${feature.properties.voltage || 'Unknown'}<br>
                                    <b>ID:</b> ${feature.properties.id || 'Unknown'}
                                `);
                            }
                        });

                        fetch(geojsonUrlProjekty)
                            .then(response => response.json())
                            .then(projektyGeojsonData => {
                                projektyLayer = L.geoJSON(projektyGeojsonData, {
                                    pointToLayer: function(feature, latlng) {
                                        return L.circleMarker(latlng, {
                                            radius: 6, // Радіус точки
                                            fillColor: "black", // Колір заповнення
                                            color: "yellow", // Колір обведення
                                            weight: 1, // Товщина обведення
                                            opacity: 1, // Прозорість обведення
                                            fillOpacity: 1 // Прозорість заповнення
                                        });
                                    },
                                    onEachFeature: function(feature, layer) {
                                        layer.bindPopup(`
                                            <b>Name:</b> ${feature.properties.Name || 'Unknown'}<br>
                                            <b>voltage:</b> ${feature.properties.voltage || 'Unknown'}
                                        `);
                                    }
                                });


                                fetch(geojsonUrlRecons)
                                    .then(response => response.json())
                                    .then(reconsGeojsonData => {
                                        reconsLayer = L.geoJSON(reconsGeojsonData, {
                                            style: function(feature) {
                                                // Логіка для зміни кольору залежно від значення voltage
                                                if (feature.properties.voltage && feature.properties.voltage.includes('220')) {
                                                    return { color: 'green', weight: 3, dashArray: '10' }; // Зелений для 220
                                                } else if (feature.properties.voltage && feature.properties.voltage.includes('400')) {
                                                    return { color: 'red', weight: 3, dashArray: '10' }; // Червоний для 400
                                                } else {
                                                    return { color: 'purple', weight: 3, dashArray: '10' }; // Фіолетовий для всього іншого
                                                }
                                            },
                                            onEachFeature: function(feature, layer) {
                                                layer.bindPopup(`
                                                    <b>Name:</b> ${feature.properties.name || 'Unknown'}<br>
                                                    <b>Voltage:</b> ${feature.properties.voltage || 'Unknown'}
                                                `);
                                            }
                                        });

                                        fetch(geojsonUrlJdr)
                                            .then(response => response.json())
                                            .then(projektyGeojsonData => {
                                                projektyJdr = L.geoJSON(projektyGeojsonData, {
                                                    pointToLayer: function(feature, latlng) {
                                                        return L.circleMarker(latlng, {
                                                            radius: 10, // Радіус точки
                                                            fillColor: "black", // Колір заповнення
                                                            color: "orange", // Колір обведення
                                                            weight: 2, // Товщина обведення
                                                            opacity: 1, // Прозорість обведення
                                                            fillOpacity: 1 // Прозорість заповнення
                                                        });
                                                    },
                                                    onEachFeature: function(feature, layer) {
                                                        layer.bindPopup(`
                                                            <b>Назва:</b> ${feature.properties.Name || 'Unknown'}<br>
                                                            <b>Потужність:</b> ${feature.properties.Power || 'Unknown'} MW<br>
                                                            <b>Опис:</b> ${feature.properties.Description || 'Unknown'}<br>
                                                        `);
                                                    }
                                                });

                                                map.createPane('borderPane');
                                                map.getPane('borderPane').style.zIndex = 400;

                                                fetch(geojsonUrlBorder)
                                                    .then(response => response.json())
                                                    .then(borderGeojsonData => {
                                                        borderLayer = L.geoJSON(borderGeojsonData, {
                                                            pane: 'borderPane',
                                                            style: {
                                                                color: 'black', // Колір шару
                                                                weight: 1, // Товщина ліній
                                                                fillOpacity: 0
                                                            },
                                                            interactive: false
                                                            
                                                        
                                                        });
                                                        var geoJsonClusterGroup = L.markerClusterGroup({
                                                            spiderfyOnMaxZoom: true, // Розпакування кластерів при максимальному масштабі
                                                            showCoverageOnHover: false, // Відключення області кластеру при наведенні
                                                            zoomToBoundsOnClick: true, // Автозбільшення при кліку на кластер
                                                            
                                                            spiderLegPolylineOptions: {
                                                                weight: 0,
                                                            },

                                                            spiderfyShapePositions: function (count, centerPt) {
        // Рівномірне розташування точок навколо центру
                                                                var radius = 40; // Радіус розташування
                                                                var angleStep = (2 * Math.PI) / count;

                                                                return Array.from({ length: count }, (_, i) => {
                                                                    var angle = i * angleStep;
                                                                    return new L.Point(
                                                                        centerPt.x + radius * Math.cos(angle),
                                                                        centerPt.y + radius * Math.sin(angle)
                                                                    );
                                                                });
                                                            },
                                                            iconCreateFunction: function (cluster) {
                                                                var sumvmerezu = 0;
                                                                var sumzmerezi = 0;

                                                                // Один прохід для обчислення обох значень
                                                                cluster.getAllChildMarkers().forEach(function (marker) {
                                                                    var value1 = marker.feature.properties["Moc przyłączeniowa wprowadzana do sieci\n[MW]2"];
                                                                    if (!isNaN(value1)) {
                                                                        sumvmerezu += parseFloat(value1) /1000;
                                                                    }

                                                                    var value2 = marker.feature.properties["Moc przyłączeniowa pobierana\nz sieci [MW]1"];
                                                                    if (!isNaN(value2)) {
                                                                        sumzmerezi += parseFloat(value2) / 1000;
                                                                    }
                                                                });

                                                                // Створення іконки
                                                                return L.divIcon({
                                                                    html: `
                                                                        <div style="background-color: rgba(0, 123, 255, 0.3); 
                                                                                    border-radius: 50%; 
                                                                                    display: flex;
                                                                                    justify-content: center;
                                                                                    align-items: center;
                                                                                    flex-direction: column;
                                                                                    width: 50px; 
                                                                                    height: 50px; 
                                                                                    text-align: center; 
                                                                                    color: white; 
                                                                                    font-weight: bold;">
                                                                            <div style="color: blue;">${sumvmerezu.toFixed(2)}</div>
                                                                            <div style="color: red;">-${sumzmerezi.toFixed(2)}</div>
                                                                        </div>
                                                                    `,
                                                                    className: 'custom-cluster-icon',
                                                                    iconSize: [50, 50]
                                                                });
                                                            }
                                                        });

                                                        function getColorByInstallationType(type) {
                                                            if (type === 'PV' || type === 'FW' || type === 'JBM'|| type === 'MEE+PV'|| type === 'MEE+PVI'|| type === 'MEE+PVI'|| type === 'MEE+PVD'|| type === 'MEE+FW'|| type === 'FW+MEE'|| type === 'MEE+FW+PV'|| type === 'FW+PV'|| type === 'PV+FW'|| type === 'MEE+PV+FW') {
                                                                return 'purple'; // Фіолетовий
                                                            } else if (type === 'MFW') {
                                                                return 'blue'; // Синій
                                                            } else if (type === 'JW' || type === 'BG' || type === 'BGP'|| type === 'BGP+BG') {
                                                                return 'yellow'; // Жовтий
                                                            } else if (type === 'MEE') {
                                                                return 'black'; // Чорний
                                                            } else if (type === 'EJ') {
                                                                return 'orange'; // Помаранчевий
                                                            } else {
                                                                return 'gray'; // Сірий (для інших значень)
                                                            }
                                                        }

                                                        // Завантаження GeoJSON
                                                        var prelunJsonUrl = 'https://mark-000.github.io/pl-power-vis-map.github.io/przylaczenie_updated_data_all.geojson';

                                                        fetch(prelunJsonUrl)
                                                            .then(response => response.json())
                                                            .then(geojsonData => {
                                                                // Додавання GeoJSON до кластерної групи
                                                                var gprelunJsonLayer = L.geoJSON(geojsonData, {
                                                                    pointToLayer: function (feature, latlng) {
                                                                        var color = getColorByInstallationType(feature.properties['Rodzaj instalacji']);
                                                                        // Налаштування стилю маркерів
                                                                        return L.circleMarker(latlng, {
                                                                            radius: 8,
                                                                            fillColor: color,
                                                                            color: '#000',
                                                                            weight: 1,
                                                                            opacity: 1,
                                                                            fillOpacity: 0.8
                                                                        });
                                                                    },
                                                                    onEachFeature: function (feature, layer) {
                                                                        // Додавання спливаючого вікна для кожної точки
                                                                        layer.bindPopup(`
                                                                            <b>Станція:</b> ${feature.properties.name || 'Невідомо'}<br>
                                                                            <b>подається в мережу:</b> ${feature.properties['Moc przyłączeniowa wprowadzana do sieci\n[MW]2'] || 'Невідомо'}<br>
                                                                            <b>споживається з мережі:</b> ${feature.properties['Moc przyłączeniowa pobierana\nz sieci [MW]1'] || 'Невідомо'}<br>
                                                                            <b>Тип:</b> ${feature.properties['Rodzaj instalacji'] || 'Невідомо'}<br>
                                                                            <b>Дата:</b> ${feature.properties['Data doręczenia Warunków Przyłączenia'] || 'Невідомо'}<br>
                                                                        `);
                                                                    }
                                                                });

                                                                // Додавання шару до кластерної групи
                                                                geoJsonClusterGroup.addLayer(gprelunJsonLayer);      
                        // Додавання контролю для перемикання шарів
                                                var overlays = {
                                                    "<span style='color: black;'>Польща</span>": borderLayer,
                                                    "<span style='color: purple;'>400kV Лінії</span>": layer400,
                                                    "<span style='color: green;'>220kV Лінії</span>": layer220,
                                                    "<span style='color: red;'>110kV Лінії</span>": layer110,
                                                    "<span style='color: black;'>Межі операторів</span>": arcgisLayer,
                                                    "<span style='color: black;'>PSE підстанції</span>": gpzLayer,// Додаємо шар з ArcGIS
                                                    "<span style='color: black;'>Підключення</span>": geoJsonClusterGroup,
                                                    "<span style='color: black;'>АЕС</span>": projektyJdr,
                                                    "<span style='color: black;'>PSE проекти GPZ</span>": projektyLayer,
                                                    "<span style='color: red; text-decoration: underline;'>PSE проекти Linii</span>": reconsLayer
                                                };
                                                
                                // Додавання контролю для перемикання шарів
                                L.control.layers(null, overlays).addTo(map);
                                borderLayer.addTo(map);

                // Додавання шарів на карту після ініціалізації контролю
                //layer220.addTo(map); // Додаємо шар 220 на карту
                //layer400.addTo(map); // Додаємо шар 400 на карту
                //layer110.addTo(map); // Додаємо новий шар 110 на карту
               //arcgisLayer.addTo(map); // Додаємо шар ArcGIS на карту
                                    })
                                    .catch(error => console.error('Помилка завантаження GeoJSON:', error));
                                })
                                .catch(error => console.error('Error loading Border GeoJSON:', error));
                            })
                            .catch(error => console.error('Error loading Jdr GeoJSON:', error));
                        })
                        .catch(error => console.error('Error loading Recons GeoJSON:', error));
                    })
                    .catch(error => console.error('Error loading Projekty GeoJSON:', error));
                })
                .catch(error => console.error('Error loading GPZ GeoJSON:', error));
            })
            .catch(error => console.error('Error loading GeoJSON:', error));
            

    </script>
</body>
</html>
